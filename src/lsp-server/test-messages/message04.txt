Content-Length: 10178

{"jsonrpc":"2.0","method":"textDocument\/didOpen","params":{"textDocument":{"version":1,"languageId":"c","uri":"file:\/\/\/Users\/jhr\/Work\/smlnj\/sml-llvm\/llvm-codegen\/runtime\/kernel\/globals.c","text":"\/*! \\file globals.c\n *\n * COPYRIGHT (c) 2019 The Fellowship of SML\/NJ (http:\/\/www.smlnj.org)\n * All rights reserved.\n *\/\n\n#include \"ml-base.h\"\n#include \"machine-id.h\"\n#include \"ml-values.h\"\n#include \"tags.h\"\n#include \"ml-globals.h\"\n#include \"ml-objects.h\"\n#include \"ml-limits.h\"\n#include \"c-globals-tbl.h\"\n\n#ifdef SIZES_C64_ML32\nvoid PatchAddrs ();\n#endif\n\n#ifndef SIZES_C64_ML32\n\ntypedef struct {\n    ml_val_t\tdesc;\n    char\t*s;\n    ml_val_t\tlen;\n} ml_string_t;\n\n#define ML_STRING(id, s)\t\t\t\t\\\n    ml_string_t id = {\t\t\t\t\t\\\n\tDESC_string,\t\t\t\t\t\\\n\ts,\t\t\t\t\t\t\\\n\tINT_CtoML(sizeof(s)-1)\t\t\t\t\\\n    }\n\n\/* Exceptions are identified by (string ref) values *\/\n#define ML_EXNID(ex,name)\t\t\t\t\\\n    ML_STRING(CONCAT(ex,_s), name);\t\t\t\\\n    ml_val_t CONCAT(ex,_id0) [2] = {\t\t\t\\\n\tDESC_ref,\t\t\t\t\t\\\n\tPTR_CtoML(&(CONCAT(ex,_s).s))\t\t\t\\\n    }\n\n#define ASM_CLOSURE(name)\t\t\t\t\\\n    extern ml_val_t CONCAT(name,_a)[];\t\t\t\\\n    ml_val_t CONCAT(name,_v)[2] = {\t\t\t\\\n\tMAKE_DESC(1,DTAG_record),\t\t\t\\\n\tPTR_CtoML(CONCAT(name,_a))\t\t\t\\\n    }\n\n#else \/* SIZES_C64_ML32 *\/\n\/* When the size of Addr_t is bigger than the size of an Word_t, we need\n * to dynamically patch the static ML objects.\n *\/\n\ntypedef struct {\n    ml_val_t\tdesc;\n    ml_val_t\ts;\n    ml_val_t\tlen;\n} ml_string_t;\n\n#define ML_STRING(id,s)\t\t\t\t\t\\\n    PVT char CONCAT(id,_data)[] = s;\t\t\t\\\n    ml_string_t id = {\t\t\t\t\t\\\n\tDESC_string, ML_unit, INT_CtoML(sizeof(s)-1)\t\\\n    }\n\n#define PATCH_ML_STRING(id)\t\t\t\t\\\n    id.s = PTR_CtoML(CONCAT(id,_data))\n\n\/* Exceptions are identified by (string ref) values *\/\n#define ML_EXNID(ex,name)\t\t\t\t\\\n    ML_STRING(CONCAT(ex,_s),name);\t\t\t\\\n    ml_val_t CONCAT(ex,_id0) [2] = { DESC_ref, }\n\n#define PATCH_ML_EXNID(ex)\t\t\t\t\\\n    PATCH_ML_STRING(CONCAT(ex,_s));\t\t\t\\\n    CONCAT(ex,_id0)[1] = PTR_CtoML(&(CONCAT(ex,_s).s))\n\n#define ASM_CLOSURE(name)\t\t\t\t\\\n    extern ml_val_t CONCAT(name,_a)[];\t\t\t\\\n    ml_val_t CONCAT(name,_v)[2] = {\t\t\t\\\n\tMAKE_DESC(1, DTAG_record),\t\t\t\\\n    }\n\n#define PATCH_ASM_CLOSURE(name)\t\t\t\t\\\n    CONCAT(name,_v)[1] = PTR_CtoML(CONCAT(name,_a))\n\n#endif\n\n\n#if (CALLEESAVE > 0)\n#define ASM_CONT(name) \t\t\t\t\t\t\t\\\n    extern ml_val_t CONCAT(name,_a)[];\t\t\t\t\t\\\n    ml_val_t *CONCAT(name,_c) = (ml_val_t *)(CONCAT(name,_a))\n#else\n#define ASM_CONT(name)\t\t\t\t\t\t\t\\\n    ASM_CLOSURE(name);\t\t\t\t\t\t\t\\\n    ml_val_t *CONCAT(name,_c) = (ml_val_t *)(CONCAT(name,_v)+1)\n#endif\n\nASM_CLOSURE(array);\nASM_CLOSURE(bind_cfun);\nASM_CLOSURE(callc);\nASM_CLOSURE(create_b);\nASM_CLOSURE(create_r);\nASM_CLOSURE(create_s);\nASM_CLOSURE(create_v);\nASM_CLOSURE(floor);\nASM_CLOSURE(logb);\nASM_CLOSURE(scalb);\nASM_CLOSURE(try_lock);\nASM_CLOSURE(unlock);\nASM_CLOSURE(handle);\n\nASM_CONT(return);\nASM_CONT(sigh_return);\nASM_CONT(pollh_return);\n\n\n\/* A ref cell initialized to unit. *\/\n#define REFCELL(z)\tml_val_t z[2] = {DESC_ref, ML_unit}\n\nREFCELL(_ProfCurrent);\nREFCELL(_PervStruct);\nREFCELL(_MLSignalHandler);\nREFCELL(_MLPollHandler);\nREFCELL(_PollEvent0);\nREFCELL(_PollFreq0);\nREFCELL(_ActiveProcs0);\n\nml_val_t\t\tRunTimeCompUnit = ML_unit;\n#ifdef ASM_MATH\nml_val_t\t\tMathVec = ML_unit;\n#endif\n\n\/* aggregate structures of length zero *\/\nconst char _ML_string0_data[1]  = {0};\nml_val_t _ML_string0[3]\t\t= {DESC_string, PTR_CtoML(_ML_string0_data), INT_CtoML(0)};\nml_val_t _ML_vector0[3]\t\t= {DESC_polyvec, ML_unit, INT_CtoML(0)};\n\nML_EXNID(_Div,\"Div\");\nML_EXNID(_Overflow,\"Overflow\");\nML_EXNID(SysErr, \"SysErr\");\n\nextern ml_val_t externlist0[];\n\n#ifdef ASM_MATH\nML_EXNID(_Ln,\"Ln\");\nML_EXNID(_Sqrt,\"Sqrt\");\n#endif\n\n\n\/* A table of pointers to global C variables that are potential roots. *\/\nml_val_t\t*CRoots[MAX_C_ROOTS] = {\n    &RunTimeCompUnit,\n    _PervStruct+1,\n    _MLSignalHandler+1,\n    _MLPollHandler+1,\n#ifdef ASM_MATH\n    &MathVec,\n#else\n    NIL(ml_val_t *),\n#endif\n    NIL(ml_val_t *), NIL(ml_val_t *)\n};\n#ifdef ASM_MATH\nint\t\tNumCRoots = 5;\n#else\nint\t\tNumCRoots = 4;\n#endif\n\n\n\/* AllocGlobals:\n *\/\nvoid AllocGlobals (ml_state_t *msp)\n{\n    ml_val_t\tRunVec;\n    ml_val_t    CStruct;\n\n#ifdef SIZES_C64_ML32\n    PatchAddrs ();\n#endif\n\n  \/* allocate the RunVec *\/\n#define RUNVEC_SZ\t12\n    ML_AllocWrite(msp,  0, MAKE_DESC(RUNVEC_SZ, DTAG_record));\n    ML_AllocWrite(msp,  1, PTR_CtoML(array_v+1));\n    ML_AllocWrite(msp,  2, PTR_CtoML(bind_cfun_v+1));\n    ML_AllocWrite(msp,  3, PTR_CtoML(callc_v+1));\n    ML_AllocWrite(msp,  4, PTR_CtoML(create_b_v+1));\n    ML_AllocWrite(msp,  5, PTR_CtoML(create_r_v+1));\n    ML_AllocWrite(msp,  6, PTR_CtoML(create_s_v+1));\n    ML_AllocWrite(msp,  7, PTR_CtoML(create_v_v+1));\n    ML_AllocWrite(msp,  8, PTR_CtoML(floor_v+1));\n    ML_AllocWrite(msp,  9, PTR_CtoML(logb_v+1));\n    ML_AllocWrite(msp, 10, PTR_CtoML(scalb_v+1));\n    ML_AllocWrite(msp, 11, PTR_CtoML(try_lock_v+1));\n    ML_AllocWrite(msp, 12, PTR_CtoML(unlock_v+1));\n    RunVec = ML_Alloc(msp, RUNVEC_SZ);\n\n  \/* allocate the CStruct *\/\n#define CSTRUCT_SZ\t12\n    ML_AllocWrite(msp,  0, MAKE_DESC(CSTRUCT_SZ, DTAG_record));\n    ML_AllocWrite(msp,  1, RunVec);\n    ML_AllocWrite(msp,  2, DivId); \/* FIXME: we no longer need this field! *\/\n    ML_AllocWrite(msp,  3, OverflowId);\n    ML_AllocWrite(msp,  4, SysErrId);\n    ML_AllocWrite(msp,  5, ProfCurrent);\n    ML_AllocWrite(msp,  6, PollEvent);\n    ML_AllocWrite(msp,  7, PollFreq);\n    ML_AllocWrite(msp,  8, MLPollHandler);\n    ML_AllocWrite(msp,  9, ActiveProcs);\n    ML_AllocWrite(msp, 10, PervStruct);\n    ML_AllocWrite(msp, 11, MLSignalHandler);\n    ML_AllocWrite(msp, 12, ML_vector0);\n    CStruct = ML_Alloc(msp, CSTRUCT_SZ);\n\n  \/* allocate 1-elem SRECORD just containing the CStruct *\/\n    REC_ALLOC1(msp, RunTimeCompUnit, CStruct);\n\n#ifdef ASM_MATH\n#define MATHVEC_SZ\t8\n    ML_AllocWrite(msp,  0, MAKE_DESC(MATHVEC_SZ, DTAG_record));\n    ML_AllocWrite(msp,  1, LnId);\n    ML_AllocWrite(msp,  2, SqrtId);\n    ML_AllocWrite(msp,  3, PTR_CtoML(arctan_v+1));\n    ML_AllocWrite(msp,  4, PTR_CtoML(cos_v+1));\n    ML_AllocWrite(msp,  5, PTR_CtoML(exp_v+1));\n    ML_AllocWrite(msp,  6, PTR_CtoML(ln_v+1));\n    ML_AllocWrite(msp,  7, PTR_CtoML(sin_v+1));\n    ML_AllocWrite(msp,  8, PTR_CtoML(sqrt_v+1));\n    MathVec = ML_Alloc(msp, MATHVEC_SZ);\n#endif\n\n} \/* end of AllocGlobals *\/\n\n\n\/* RecordGlobals:\n *\n * Record all global symbols that may be referenced from the ML heap.\n *\/\nvoid RecordGlobals ()\n{\n  \/* Misc. *\/\n    RecordCSymbol (\"nullptr\",\t\tPTR_CtoML(0));\n    RecordCSymbol (\"handle\",\t\tPTR_CtoML(handle_v+1));\n    RecordCSymbol (\"return\",\t\tPTR_CtoML(return_c));\n#if (CALLEESAVE == 0)\n    RecordCSymbol (\"return_a\",\t\tPTR_CtoML(return_a));\n#endif\n\n  \/* RunVec *\/\n    RecordCSymbol (\"RunVec.array\",\tPTR_CtoML(array_v+1));\n    RecordCSymbol (\"RunVec.bind_cfun\",\tPTR_CtoML(bind_cfun_v+1));\n    RecordCSymbol (\"RunVec.callc\",\tPTR_CtoML(callc_v+1));\n    RecordCSymbol (\"RunVec.create_b\",\tPTR_CtoML(create_b_v+1));\n    RecordCSymbol (\"RunVec.create_r\",\tPTR_CtoML(create_r_v+1));\n    RecordCSymbol (\"RunVec.create_s\",\tPTR_CtoML(create_s_v+1));\n    RecordCSymbol (\"RunVec.create_v\",\tPTR_CtoML(create_v_v+1));\n    RecordCSymbol (\"RunVec.floor\",\tPTR_CtoML(floor_v+1));\n    RecordCSymbol (\"RunVec.logb\",\tPTR_CtoML(logb_v+1));\n    RecordCSymbol (\"RunVec.scalb\",\tPTR_CtoML(scalb_v+1));\n    RecordCSymbol (\"RunVec.try_lock\",\tPTR_CtoML(try_lock_v+1));\n    RecordCSymbol (\"RunVec.unlock\",\tPTR_CtoML(unlock_v+1));\n\n  \/* CStruct *\/\n    RecordCSymbol (\"CStruct.DivId\",\t\tDivId); \/* FIXME: we can remove this *\/\n    RecordCSymbol (\"CStruct.OverflowId\",\tOverflowId);\n    RecordCSymbol (\"CStruct.SysErrId\",\t\tSysErrId);\n    RecordCSymbol (\"CStruct.PervStruct\",\tPervStruct);\n    RecordCSymbol (\"CStruct.MLSignalHandler\",\tMLSignalHandler);\n    RecordCSymbol (\"CStruct.vector0\",\t\tML_vector0);\n    RecordCSymbol (\"CStruct.profCurrent\",\tProfCurrent);\n    RecordCSymbol (\"CStruct.MLPollHandler\",     MLPollHandler);\n    RecordCSymbol (\"CStruct.pollEvent\",\t\tPollEvent);\n    RecordCSymbol (\"CStruct.pollFreq\",\t\tPollFreq);\n    RecordCSymbol (\"CStruct.activeProcs\",\tActiveProcs);\n\n  \/* null string *\/\n    RecordCSymbol (\"string0\",\t\t\tML_string0);\n\n#if defined(ASM_MATH)\n  \/* MathVec *\/\n    RecordCSymbol (\"MathVec.LnId\",\tLnId);\n    RecordCSymbol (\"MathVec.SqrtId\",\tSqrtId);\n    RecordCSymbol (\"MathVec.arctan\",\tPTR_CtoML(arctan_v+1));\n    RecordCSymbol (\"MathVec.cos\",\tPTR_CtoML(cos_v+1));\n    RecordCSymbol (\"MathVec.exp\",\tPTR_CtoML(exp_v+1));\n    RecordCSymbol (\"MathVec.ln\",\tPTR_CtoML(ln_v+1));\n    RecordCSymbol (\"MathVec.sin\",\tPTR_CtoML(sin_v+1));\n    RecordCSymbol (\"MathVec.sqrt\",\tPTR_CtoML(sqrt_v+1));\n#endif\n\n} \/* end of RecordGlobals. *\/\n\n#ifdef SIZES_C64_ML32\n\n\/* PatchAddrs:\n *\n * On machines where the size of Addr_t is bigger than the size of an Word_t,\n * we need to dynamically patch the static ML objects.\n *\/\nvoid PatchAddrs ()\n{\n    PATCH_ML_EXNID(_Div);\n    PATCH_ML_EXNID(_Overflow);\n    PATCH_ML_EXNID(SysErr);\n\n    PATCH_ASM_CLOSURE(array);\n    PATCH_ASM_CLOSURE(bind_cfun);\n    PATCH_ASM_CLOSURE(callc);\n    PATCH_ASM_CLOSURE(create_b);\n    PATCH_ASM_CLOSURE(create_r);\n    PATCH_ASM_CLOSURE(create_s);\n    PATCH_ASM_CLOSURE(create_v);\n    PATCH_ASM_CLOSURE(floor);\n    PATCH_ASM_CLOSURE(logb);\n    PATCH_ASM_CLOSURE(scalb);\n    PATCH_ASM_CLOSURE(try_lock);\n    PATCH_ASM_CLOSURE(unlock);\n    PATCH_ASM_CLOSURE(handle);\n\n#if (CALLEESAVE <= 0)\n    PATCH_ASM_CLOSURE(return);\n    PATCH_ASM_CLOSURE(sigh_return);\n#endif\n\n} \/* end of PatchAddrs *\/\n\n#endif \/* SIZES_C64_ML32 *\/\n"}}}